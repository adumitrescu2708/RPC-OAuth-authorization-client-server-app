/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "application.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

#include "server_src/database.h"
#include "server_src/end_user.h"

#define ARGC 5

static void
application_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		authRequest_t request_authorization_1_arg;
		accessRequest_t request_access_token_1_arg;
		approveTokenRequest_t approve_request_token_1_arg;
		delegateAction_t validate_delegated_action_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case request_authorization:
		_xdr_argument = (xdrproc_t) xdr_authRequest_t;
		_xdr_result = (xdrproc_t) xdr_authToken_t;
		local = (char *(*)(char *, struct svc_req *)) request_authorization_1_svc;
		break;

	case request_access_token:
		_xdr_argument = (xdrproc_t) xdr_accessRequest_t;
		_xdr_result = (xdrproc_t) xdr_accessTokenResponse;
		local = (char *(*)(char *, struct svc_req *)) request_access_token_1_svc;
		break;

	case approve_request_token:
		_xdr_argument = (xdrproc_t) xdr_approveTokenRequest_t;
		_xdr_result = (xdrproc_t) xdr_authToken_t;
		local = (char *(*)(char *, struct svc_req *)) approve_request_token_1_svc;
		break;

	case validate_delegated_action:
		_xdr_argument = (xdrproc_t) xdr_delegateAction_t;
		_xdr_result = (xdrproc_t) xdr_actionResponse_t;
		local = (char *(*)(char *, struct svc_req *)) validate_delegated_action_1_svc;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

/*
	Modified rpcgen generated source file, adding an argv parsing,
	letting server's database collect input from argv.

	In case of errors in parsing or bad usage stops the execution of the server.
*/
bool parseInput(int argc, char **argv) {
    if(argc !=  ARGC) {
        cerr << "Bad usage! Try: ./server <client_id_file> <resources_file> <aprovals_file> <valability> !" << endl;
        return false;
    }
    if(!parseInputIds(argv[1]))
        return false;
	if(!parseResources(argv[2]))
		return false;
	if(!parseAprovals(argv[3]))
		return false;

	setValabilityTokens(argv[4]);
	return true;
}

int
main (int argc, char **argv)
{
	register SVCXPRT *transp;

	pmap_unset (APPLICATION_PROG, APPLICATION_VERSION);

    if(!parseInput(argc, argv)) {
		return -1;
	}

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, APPLICATION_PROG, APPLICATION_VERSION, application_prog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (APPLICATION_PROG, APPLICATION_VERSION, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, APPLICATION_PROG, APPLICATION_VERSION, application_prog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (APPLICATION_PROG, APPLICATION_VERSION, tcp).");
		exit(1);
	}

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}
